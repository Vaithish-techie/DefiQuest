// Code generated by abigen. DO NOT EDIT.

package blockchain

import (
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"

)

// BadgeNFTMetaData contains the meta data used to generate the binding.
var BadgeNFTMetaData = &bind.MetaData{
	ABI: "[{\"type\":\"constructor\",\"inputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"to\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"authorizeMinter\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"}, ... ]", // NOTE: The ABI string is very long and has been truncated for display.
}

// BadgeNFT is a Go wrapper around an Ethereum contract.
type BadgeNFT struct {
	BadgeNFTCaller     // Read-only binding to the contract
	BadgeNFTTransactor // Write-only binding to the contract
	BadgeNFTFilterer   // Log filterer for contract events
}

// BadgeNFTCaller is a read-only Go wrapper around an Ethereum contract.
type BadgeNFTCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the caller
}

// BadgeNFTTransactor is a write-only Go wrapper around an Ethereum contract.
type BadgeNFTTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the transactor
}

// BadgeNFTFilterer is a Go wrapper around an Ethereum contract log filterer.
type BadgeNFTFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the filterer
}

// NewBadgeNFT creates a new instance of BadgeNFT, bound to a specific deployed contract.
func NewBadgeNFT(address common.Address, backend bind.ContractBackend) (*BadgeNFT, error) {
	contract, err := bindBadgeNFT(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BadgeNFT{BadgeNFTCaller: BadgeNFTCaller{contract: contract}, BadgeNFTTransactor: BadgeNFTTransactor{contract: contract}, BadgeNFTFilterer: BadgeNFTFilterer{contract: contract}}, nil
}

// NewBadgeNFTCaller creates a new read-only instance of BadgeNFT, bound to a specific deployed contract.
func NewBadgeNFTCaller(address common.Address, caller bind.ContractCaller) (*BadgeNFTCaller, error) {
	contract, err := bindBadgeNFT(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BadgeNFTCaller{contract: contract}, nil
}

// NewBadgeNFTTransactor creates a new write-only instance of BadgeNFT, bound to a specific deployed contract.
func NewBadgeNFTTransactor(address common.Address, transactor bind.ContractTransactor) (*BadgeNFTTransactor, error) {
	contract, err := bindBadgeNFT(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BadgeNFTTransactor{contract: contract}, nil
}

// NewBadgeNFTFilterer creates a new log filterer instance of BadgeNFT, bound to a specific deployed contract.
func NewBadgeNFTFilterer(address common.Address, filterer bind.ContractFilterer) (*BadgeNFTFilterer, error) {
	contract, err := bindBadgeNFT(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BadgeNFTFilterer{contract: contract}, nil
}

func bindBadgeNFT(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BadgeNFTMetaData.ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// MintBadge is a paid mutator transaction binding.
func (_BadgeNFT *BadgeNFTTransactor) MintBadge(opts *bind.TransactOpts, to common.Address, questId *big.Int, tokenURI string, rarity uint8) (*types.Transaction, error) {
	return _BadgeNFT.contract.Transact(opts, "mintBadge", to, questId, tokenURI, rarity)
}

// And so on for all other contract functions...
